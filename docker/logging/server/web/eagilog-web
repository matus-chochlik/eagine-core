#!/usr/bin/env python3
# coding: UTF-8
# Copyright (c) 2020-2021 Matus Chochlik
# Distributed under the Boost Software License, Version 1.0.
# See accompanying file LICENSE_1_0.txt or copy at
#  http://www.boost.org/LICENSE_1_0.txt

import os
import re
import io
import json
import math
import time
import flask
import decimal
import argparse
import datetime
import psycopg2
import matplotlib.pyplot as plt
import matplotlib.ticker as pltckr

# ------------------------------------------------------------------------------
# Utilities
# ------------------------------------------------------------------------------
def format_duration(s, w = 0, n_a = "N/A"):
    if s is None:
        return n_a
    if isinstance(s, str):
        s = float(s)
    if isinstance(s, datetime.timedelta):
        s = s.total_seconds()
    if s >= 60480000:
        return "%dw" % (int(s) / 604800)
    if s >= 604800:
        return "%dw %2dd" % (int(s) / 604800, (int(s) % 604800) / 86400)
    if s >= 86400:
        return "%dd %2dh" % (int(s) / 86400, (int(s) % 86400) / 3600)
    if s >= 3600:
        return "%dh %02dm" % (int(s) / 3600, (int(s) % 3600) / 60)
    if s >= 60:
        return "%dm %02ds" % (int(s) / 60, int(s) % 60)
    if s >= 10:
        return "%ds" % int(s)
    if s >= 0.01:
        return "%dms" % int(s*10**3)
    if s <= 0.0:
        return "0"
    return "%dÎ¼s" % int(s*10**6)
# ------------------------------------------------------------------------------
# Argument parsing
# ------------------------------------------------------------------------------
class ArgumentParser(argparse.ArgumentParser):
    # -------------------------------------------------------------------------
    def _positive_int(self, x):
        try:
            assert(int(x) > 0)
            return int(x)
        except:
            self.error("`%s' is not a positive integer value" % str(x))
    # -------------------------------------------------------------------------
    def _port_number(self, x):
        try:
            p = int(x)
            if (p > 1) and (p < 2**16):
                return p
            self.error("'%d' is not a valid port number" % (p))
        except TypeError:
            self.error("port number must be an integer value" )
    # -------------------------------------------------------------------------
    def __init__(self, **kw):
        argparse.ArgumentParser.__init__(self, **kw)

        self.add_argument(
            "--psql-host",
            metavar='HOSTNAME',
            dest='psql_host',
            action="store",
            default="localhost"
        )

        self.add_argument(
            "--psql-port",
            metavar='PORT-NUMBER',
            dest='psql_port',
            type=self._positive_int,
            action="store",
            default=5432
        )

        self.add_argument(
            "--psql-name",
            metavar='DATABASE',
            dest='psql_name',
            action="store",
            default="eagilog"
        )

        self.add_argument(
            "--psql-user",
            metavar='USERNAME',
            dest='psql_user',
            action="store",
            default="eagilog"
        )

        self.add_argument(
            "--psql-password",
            metavar='PASSWORD',
            dest='psql_password',
            action="store",
            default=None
        )

        self.add_argument(
            "--psql-pass-file",
            metavar='FILE-PATH',
            dest='psql_password_file',
            action="store",
            default=None
        )

        self.add_argument(
            "--port", "-P",
            dest="port_number",
            metavar="NUMBER",
            type=self._port_number,
            default=34913,
            help="""
            Specifies the port number (34913) by default.
            """
        )

        self.add_argument(
            "--debug", "-D",
            dest="debug_mode",
            action="store_true",
            default=False,
            help="""
            Starts the service in debug mode.
            """
        )

    # -------------------------------------------------------------------------
    def process_parsed_options(self, options):
        return options

    # -------------------------------------------------------------------------
    def parse_args(self):
        class _Options(object):
            # ------------------------------------------------------------------
            def __init__(self, options):
                self.__dict__.update(options.__dict__)

            # ------------------------------------------------------------------
            def get_psql_password(self):
                if self.psql_password is None:
                    def _getpwd(passfd):
                        return passfd.readline().rstrip().split(":")[-1]

                    try:
                        with open(self.psql_password_file, "r") as passfd:
                            self.psql_password = _getpwd(passfd)
                    except:
                        try:
                            with open(os.path.expanduser("~/.pgpass"), "r") as passfd:
                                self.psql_password = _getpwd(passfd)
                        except:
                            self.psql_password = getpass.getpass("psql password: ")
                return self.psql_password

        return _Options(self.process_parsed_options(
            argparse.ArgumentParser.parse_args(self)))

# ------------------------------------------------------------------------------
def get_argument_parser():
    return ArgumentParser(
        prog=os.path.basename(__file__),
        description="""Web/REST server for EAGilog server"""
    )
# ------------------------------------------------------------------------------
# Flask app
# ------------------------------------------------------------------------------
class EAGilogWebApp(flask.Flask):
    # --------------------------------------------------------------------------
    @staticmethod
    def get_static_folder():
        return os.path.join(
            os.path.realpath(
                os.environ.get('EAGILOG_WEB_ROOT', os.path.dirname(__file__))
            ), 'static')
    # --------------------------------------------------------------------------
    def __init__(self):
        flask.Flask.__init__(self, "eagilog-web")
        self.config["STATIC_FOLDER"] = self.get_static_folder()

# ------------------------------------------------------------------------------
eagilog_web = None
eagilog_web_app = EAGilogWebApp()
# ------------------------------------------------------------------------------
# PostgreSQL connection
# ------------------------------------------------------------------------------
class PSQLConnection(object):
    # --------------------------------------------------------------------------
    def __init__(self, options):
        self._pg_conn = psycopg2.connect(
            user=options.psql_user,
            password=options.get_psql_password(),
            database=options.psql_name,
            host=options.psql_host,
            port=options.psql_port)
        self._pg_conn.__enter__()
    # --------------------------------------------------------------------------
    def __del__(self):
        try: self._pg_conn.close()
        except: pass
    # --------------------------------------------------------------------------
    def cursor(self):
        return self._pg_conn.cursor()

# ------------------------------------------------------------------------------
# App
# ------------------------------------------------------------------------------
class EAGilogWeb(object):
    # --------------------------------------------------------------------------
    def __init__(self, options):
        self._options = options
        self._start_time = time.time()
        self._psql_conn = None

        self._stat_getters = {
            "uptime_seconds": self.uptime_seconds,
            "psql_stream_count": self.psql_stream_count,
            "psql_active_stream_count": self.psql_active_stream_count,
            "psql_interval_count": self.psql_interval_count,
            "psql_entry_count": self.psql_entry_count,
            "psql_entry_arg_count": self.psql_entry_arg_count,
            "psql_schema_data_size_mib": self.psql_schema_data_size_mib
        }

    # --------------------------------------------------------------------------
    # Helper functions
    # --------------------------------------------------------------------------
    def psql_connect(self):
        return PSQLConnection(self._options)

    # --------------------------------------------------------------------------
    def psql_cursor(self):
        if self._psql_conn is None:
            self._psql_conn = self.psql_connect()
        return self._psql_conn.cursor()

    # --------------------------------------------------------------------------
    def fix_for_json(self, value):
        if isinstance(value, decimal.Decimal):
            return float(value)
        return value

    # --------------------------------------------------------------------------
    def _gather_values(self, getters):
        values = {}
        for key, getter in getters.items():
            try: value = getter()
            except Exception as error: value = str(error)

            if type(value) is float:
                values[key] = round(value, 2)
            else:
                values[key] = value
        return values

    # --------------------------------------------------------------------------
    # Stat value getters
    # --------------------------------------------------------------------------
    def uptime_seconds(self):
        return time.time() - self._start_time

    # --------------------------------------------------------------------------
    def psql_stream_count(self):
        try:
            with self.psql_cursor() as cur:
                cur.execute("SELECT count(1) FROM eagilog.stream")
                return int(cur.fetchone()[0])
        except Exception as err:
            return str(err)

    # --------------------------------------------------------------------------
    def psql_active_stream_count(self):
        try:
            with self.psql_cursor() as cur:
                cur.execute("SELECT count(1) FROM eagilog.active_stream")
                return int(cur.fetchone()[0])
        except Exception as err:
            return str(err)

    # --------------------------------------------------------------------------
    def psql_interval_count(self):
        try:
            with self.psql_cursor() as cur:
                cur.execute("SELECT count(1) FROM eagilog.profile_interval")
                return int(cur.fetchone()[0])
        except Exception as err:
            return str(err)

    # --------------------------------------------------------------------------
    def psql_entry_count(self):
        try:
            with self.psql_cursor() as cur:
                cur.execute("SELECT count(1) FROM eagilog.entry")
                return int(cur.fetchone()[0])
        except Exception as err:
            return str(err)

    # --------------------------------------------------------------------------
    def psql_entry_arg_count(self):
        try:
            with self.psql_cursor() as cur:
                cur.execute("SELECT count(1) FROM eagilog.entry_and_args")
                return int(cur.fetchone()[0])
        except Exception as err:
            return str(err)

    # --------------------------------------------------------------------------
    def psql_schema_data_size_mib(self):
        try:
            with self.psql_cursor() as cur:
                cur.execute("SELECT eagilog.schema_data_size_mib()")
                return float(cur.fetchone()[0])
        except Exception as err:
            return str(err)

    # --------------------------------------------------------------------------
    # API functions
    # --------------------------------------------------------------------------
    def api_stats(self):
        return self._gather_values(self._stat_getters)

    # --------------------------------------------------------------------------
    def api_active_stream_main_progress(self):
        try:
            query = """
            SELECT
                stream_id,
                EXTRACT(epoch FROM entry_time_min) AS entry_time_min_s,
                EXTRACT(epoch FROM entry_time_cur) AS entry_time_cur_s,
                EXTRACT(epoch FROM entry_time_now) AS entry_time_now_s,
                EXTRACT(epoch FROM age) AS age_s,
                value_min,
                value_cur,
                value_max,
                done
            FROM eagilog.active_stream
            JOIN eagilog.stream_main_progress
            USING(stream_id)
            """
            with self.psql_cursor() as cur:
                cur.execute(query)
                columns = [(idx, desc[0]) for idx, desc in enumerate(cur.description)]
                result = []
                while True:
                    row = cur.fetchone()
                    if row is None:
                        break
                    obj = {col: self.fix_for_json(row[idx]) for idx, col in columns}
                    result.append(obj)
                return result
        except Exception as err:
            return str(err)

    # --------------------------------------------------------------------------
    @staticmethod
    def _blend(lt, rt, f):
        return tuple(max(min(l * (1.0 - f) + r * f, 1), 0) for l, r in zip(lt, rt))
    # --------------------------------------------------------------------------
    # Plots
    # --------------------------------------------------------------------------
    def img_active_stream_main_progress(self, imgfmt="svg"):
        try:
            query = """
            SELECT
                stream_id,
                done,
                EXTRACT(epoch FROM elapsed_time) AS elapsed_time_s,
                EXTRACT(epoch FROM remaining_time) AS remaining_time_s,
                EXTRACT(epoch FROM age) AS age_s
            FROM eagilog.active_stream
            JOIN eagilog.stream_main_progress
            USING(stream_id)
            """
            with self.psql_cursor() as cur:
                cur.execute(query)
                data = []
                while True:
                    row = cur.fetchone()
                    if row is None:
                        break
                    data.append(tuple(self.fix_for_json(v) for v in row))
        except:
            data = tuple()

        def _make_label(s):
            return "%.1f%%\n%s/%s" % (
                s[1] * 100.0,
                format_duration(s[2]),
                format_duration(s[3])
            )

        def _make_color(s):
            return self._blend(
                (0.7, 0.2, 0.1),
                (0.3, 0.8, 0.3),
                math.exp(-s[4] / (15.0 * 60.0)))

        y_pos = [y for y in range(len(data))]
        streams = [str(e[0]) for e in data]
        progress = [(e[1] * 100) for e in data]
        labels_l = [_make_label(e) if e[1] <  0.42 else "" for e in data]
        labels_r = [_make_label(e) if e[1] >= 0.42 else "" for e in data]
        colors = [_make_color(e) for e in data]

        fig, spl = plt.subplots()
        plt.style.use('dark_background')
        fig.set_size_inches(16, max(len(data) * 0.6, 2.0))

        bars = spl.barh(y_pos, progress, color=colors)
        x1,x2,y1,y2 = spl.axis()
        spl.axis((0,100,y1,y2))
        
        spl.bar_label(bars, labels_l, padding=10, color='white', fontweight='bold')
        spl.bar_label(bars, labels_r, padding=-100, color='black', fontweight='bold')

        spl.set_yticks(y_pos, labels=streams)
        spl.invert_yaxis() 
        spl.set_xlabel("percent")
        spl.set_ylabel("streams")
        spl.grid(which="both", axis="both", alpha=0.3)

        output = io.BytesIO()
        plt.savefig(
            output,
            transparent=True,
            format=imgfmt
        )
        fig.clear()
        plt.close(fig)
        output.seek(0)

        return output

# ------------------------------------------------------------------------------
# Routing
# ------------------------------------------------------------------------------
# Routing - API
# ------------------------------------------------------------------------------
@eagilog_web_app.route("/api/stats")
def ewa_api_stats():
    return json.dumps(eagilog_web.api_stats())
# ------------------------------------------------------------------------------
@eagilog_web_app.route("/api/active_stream_main_progress")
def ewa_api_active_stream_main_progress():
    return json.dumps(eagilog_web.api_active_stream_main_progress())
# ------------------------------------------------------------------------------
# Routing - Web
# ------------------------------------------------------------------------------
@eagilog_web_app.route("/image/active_stream_main_progress.svg")
def ewa_img_active_stream_main_progress():
    try:
        return flask.send_file(
            eagilog_web.img_active_stream_main_progress(),
            mimetype="image/svg+xml"
        )
    except Exception as error:
        return str(error)
# ------------------------------------------------------------------------------
# Web root
# ------------------------------------------------------------------------------
@eagilog_web_app.route("/")
def ewa_server_root():
    return flask.redirect("/static/index.html", code=302)
# ------------------------------------------------------------------------------
# Main
# ------------------------------------------------------------------------------
if __name__ == "__main__":
    argparser = get_argument_parser()
    options = argparser.parse_args()
    eagilog_web = EAGilogWeb(options)
    if options.debug_mode:
        eagilog_web_app.run(
            debug=options.debug,
            host="0.0.0.0",
            port=options.port_number
        )
    else:
        from gevent.pywsgi import WSGIServer
        srvr = WSGIServer(("0.0.0.0", options.port_number), eagilog_web_app)
        try: srvr.serve_forever()
        except KeyboardInterrupt:
            pass
# ------------------------------------------------------------------------------
